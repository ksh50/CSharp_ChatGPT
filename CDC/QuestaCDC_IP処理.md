## USER
AMD FPGAのコードにQuestaCDCの非同期解析を適用するとします。

FPGAコードにはMMCMのIPが含まれているとします。

その場合、MMCMを生成時に作られるファイルの中でQuestaCDCでコンパイル対象とするファイルはどれに当たりますか？

## ASSISTANT
Questa CDC（Clock Domain Crossing）解析をAMD FPGA設計に適用する際に、MMCM（Mixed-Mode Clock Manager）が含まれている場合、Questa CDCのコンパイル対象に**含めるべきファイルは、MMCMのブラックボックス（インターフェース）として機能するファイル**です。つまり、**MMCMのラッパーまたはスタブ（スタブ宣言）となるファイル**を使用し、**内部の動作ロジックは不要**という扱いになります。

### 具体的には：

VivadoでMMCM IPを生成した場合、以下のようなファイルが作成されます：

- `<mmcm_name>.vhd`（または`.v`）: MMCMのトップラッパー
- `<mmcm_name>_clk_wiz.vhd`（または`.v`）: 実装詳細
- `<mmcm_name>_clk_wiz_stub.vhdl`（または`.v`）: ブラックボックス宣言（合成ツールなどがインスタンスを認識できるようにするためのスタブ）

---

### Questa CDCにおける扱い：

Questa CDCで重要なのは、**CDCパスを検出し正しく制約すること**です。そのため、MMCMの**内部動作は無視**して、**クロックの入出力の関係だけが分かれば十分**です。

#### よって、Questa CDC用には以下のように扱います：

- **使用すべきファイル：**  
  `*.stub.vhd` または `*.stub.v`（ブラックボックス用スタブファイル）

- **使用しないファイル：**  
  `*_clk_wiz.vhd` などMMCMの詳細な実装ロジックを含むファイル（Questa CDCには不要）

---

### まとめ：

MMCM付きのAMD FPGA設計にQuesta CDCを適用する際、**MMCMに関しては、Vivadoが生成する `.stub.vhd` または `.stub.v` のスタブファイルをコンパイル対象に含めればOK**です。これにより、QuestaはMMCMをブラックボックスとして扱い、正しくCDC解析が行えます。

---

必要であれば、スタブファイルに手動で `syn_black_box` 属性や `dont_touch` 属性を追加することもあります（ツールの設定次第）。また、QuestaのCDC制約ファイル（.sdc）でMMCM出力クロックを適切に定義しておくことも重要です。

## USER
IP部分にラッパーファイル、スタブファイルを割り当てるとのことで承知しました。

言葉の意味ですが、ラッパーは対象を包みこんで内部を見せないようにするイメージがあるのですが、スタブという言葉には分岐させるイメージがあります。ですが、IPを分岐させるイメージが思い描けません。なぜスタブファイルという名前がついているのでしょうか？

## ASSISTANT
とても良いご質問です。「**スタブ（stub）**」という言葉は一見すると「分岐」や「枝」っぽいイメージを連想させますが、**ソフトウェアやHDL設計の文脈における「スタブ」**は、少し異なる意味で使われています。

---

### スタブ（stub）の本来の意味

「stub」は英語で「切り株」「突起」「未完成な小片」のような意味があります。これが転じて、**「最小限の情報だけを持った仮の置き物」**という意味で技術分野では使われています。

---

### 技術分野でのスタブの使われ方（例）：

| 分野             | スタブの役割                                 |
|------------------|----------------------------------------------|
| ソフトウェア開発 | 関数やAPIの「仮実装」。外部とのインターフェースだけを持ち、内部処理は空か簡略化されている。 |
| テスト設計       | 本物のモジュールがまだ用意できないときに、呼び出し元との接続だけを満たすように使われる。 |
| HDL設計          | IPなどのブラックボックスのインターフェースだけを定義した空のエンティティやモジュール。     |

---

### HDLのスタブファイルの意味

VivadoなどでIPコアを生成すると、自動的に `*_stub.v` や `*_stub.vhdl` のようなファイルが出てきますが、これは：

- ポートの宣言のみ
- 中身の実装（architecture部分）は空 or 未定義
- 合成ツールや検証ツールに「ここにこういうポートを持つコンポーネントがあります」と教えるためのダミー

つまり、「**まだ中身は作ってないけど、こういう形の部品がここにありますよ**」という目印なのです。

---

### なぜ「分岐」っぽく見えるか？

「stub」はたしかに「木の枝の名残」や「切り株」など、物理的に何かが分かれていたり、途切れていたりするイメージを持つ言葉です。そのため「分岐」のような連想が出るのは自然です。

しかし技術用語では、「**途中で切れている**」「**中身が無いけど外形だけある**」という側面が強調されます。

---

### ラッパーとの違い

| 種別     | 目的                             | 実装の有無         |
|----------|----------------------------------|--------------------|
| ラッパー | 内部のIPやモジュールを包んで接続を整理する | 内部に本物のロジックが存在 |
| スタブ   | 実体の代わりに仮で置く、ツールが認識できるようにする | 中身は空、インターフェースのみ |

---

### まとめ

> **スタブファイルとは、「この場所にこういうIPがありますよ」という*目印*や*ダミー宣言*のために使う、外形だけの仮実装です。**

「分岐」ではなく「切り株（stub）」というイメージが一番近いです。つまり「ここに何かが生えてくる（本物の実装が入る）予定だよ」という場所を示すものなんですね。

もしソフトウェア開発の経験があるなら、APIモックやインターフェースの「ダミー実装（空の関数）」を思い浮かべると感覚が近いです。

## USER
ありがとうございます。スタブのイメージがわかりやすくなりました。

QuestaCDCではIP部分になにもないときに、自動でブラックボックスとして扱ってくれないのでしょうか？

## ASSISTANT
どういたしまして！ご理解が深まったようでうれしいです。

さて、**QuestaCDCがIP部分を自動でブラックボックスとして扱ってくれるかどうか**についてですが、これは**基本的には自動でブラックボックス扱いにはなりません**。以下に詳しく説明します。

---

### QuestaCDCにおけるブラックボックスの扱い

QuestaCDC（およびその基盤であるQuesta Advanced Verificationツール群）は、**CDC解析においてモジュールの詳細な構造（階層、FFの配置など）を調べる必要がある**ため、次のように動作します：

#### 1. **モジュールがインスタンスされているが定義がない場合**
- Questaは「未定義のモジュール」として**エラーを出すか、スキップするだけで無視される**可能性が高いです。
- つまり、**CDCパスの途中で何が起こっているかを追えなくなる**ため、そのIP経由のCDCパスは**解析対象外**になります。

#### 2. **明示的にブラックボックスとしてスタブを与えた場合**
- モジュール定義は存在し、**ポート情報があるため、CDCツールが「ここに何かがある」と認識可能**になります。
- こうすることで、**入力クロック・出力クロックの情報を手がかりに、CDCパスを解析対象に含める**ことができます。

---

### 結論：スタブやブラックボックス宣言は**明示的に与える必要がある**

そのため、Vivadoなどで生成されたIPについては：

- **`*_stub.v`（または`*_stub.vhdl`）のようなスタブファイルをCDC解析に含める**
- もしくは、**手動で同等のブラックボックスモジュール宣言を書く**

というのが基本的なスタンスです。

---

### 補足：オプションで「ブラックボックス化」を強制することも可能

Questaにはコマンドラインオプションや設定ファイルで：

- `set_black_box` コマンド
- `-blackbox` オプション

などを用いて、「このモジュールは中身無視してブラックボックス扱いしてくれ」と**強制する手段**もありますが、**スタブファイルを使う方が自然でトラブルが少ない**です。

---

### まとめ

- QuestaCDCは**未定義モジュールを自動でブラックボックス扱いにはしません**。
- **スタブファイルを明示的に含める**ことで、CDC解析対象として正しく認識させることができます。
- 必要に応じて `set_black_box` などの制約でブラックボックス化も可能です。

---

ご希望であれば、`set_black_box` の書き方や、Questa用.tclファイルの例などもご紹介できますよ。

## USER
QuestaCDCでは自動ではブラックボックスとして扱ってくれないとのことで承知しました。

自分の環境でIP生成したフォルダを見たところ、スタブファイルが生成されていました。

アーキテクチャ部分だけ書き出すと、下記のように記載されています。解説いただけますか？

architecture stub of clk_wiz_0 is
attribute syn_black_box : boolean;
attribute black_box_pad_pin : string;
attribute syn_black_box of stub : architecture is true;
attribute black_box_pad_pin of stub : architecture is "clk_out1,reset,locked,clk_in1";
begin
end;

## ASSISTANT
はい、以下の `architecture stub of clk_wiz_0 is` 以下の記述は、**IP（この場合は MMCM ラッパーIP）をブラックボックスとしてツールに認識させるための構文**です。Vivado が自動生成するスタブファイルの典型的なパターンですね。詳しく解説します。

---

### 全体の構造

```vhdl
architecture stub of clk_wiz_0 is
  attribute syn_black_box : boolean;
  attribute black_box_pad_pin : string;
  attribute syn_black_box of stub : architecture is true;
  attribute black_box_pad_pin of stub : architecture is "clk_out1,reset,locked,clk_in1";
begin
end;
```

この構文は **ツール（主に合成・解析系）に対して「中身のないIPである」ことを伝える目的**のものです。

---

### 各行の解説

#### `architecture stub of clk_wiz_0 is`
- `clk_wiz_0` というエンティティに対する `stub` という名前のアーキテクチャ。
- 中身は空（`begin ... end;` の間に何もない）＝**動作を持たないブラックボックス宣言**です。

#### `attribute syn_black_box : boolean;`
- `syn_black_box` は **合成ツール向けの属性**。
- 「これはブラックボックスで、合成しないでね」という意味を持ちます。

#### `attribute black_box_pad_pin : string;`
- こちらは **I/Oピンのリストを指定するための属性**です。
- 解析ツールに「このIPはこういうピン構成だよ」と教える役割があります。

#### `attribute syn_black_box of stub : architecture is true;`
- `stub` アーキテクチャに対して、`syn_black_box` 属性を `true` に設定。
- → このアーキテクチャは**ブラックボックスであると宣言**しています。

#### `attribute black_box_pad_pin of stub : architecture is "clk_out1,reset,locked,clk_in1";`
- ピン名（ポート名）をカンマ区切りで列挙。
- **ブラックボックスとして扱うときに、どんなポートがあるかをツールに伝える**ためです。

#### `begin ... end;`
- 本来はここにロジックが入りますが、何も書かれていないので**完全なブラックボックス**です。

---

### このスタブファイルの役割

このファイルは：

- Vivado などの合成ツールに「IPの中身は触らないで、ポートだけ見てね」
- QuestaCDC に対して「ポート構成はこれだよ、中身は見えないよ」

と**伝えるための宣言ファイル**です。**中身の構造や動作は一切含まず、インターフェースだけを定義**します。

---

### QuestaCDC におけるこの構文の利点

- **CDC解析に必要なクロックポートの特定が可能**
- IPを**内部まで展開せずにブラックボックスとして扱う**ので解析速度が上がる
- 中身を知らなくても、**CDCパスの前後で何が起きているかを把握できる**

---

### まとめ

この `architecture stub` に書かれた属性宣言は、**VivadoやQuestaのようなツールに対して「このIPは中身がない仮モジュールです」と明示するための記法**です。

- `syn_black_box`：合成・解析ツールに「中身なし」宣言
- `black_box_pad_pin`：どんなポートがあるかの一覧
- `begin ... end` に中身が無いことで「機能なし」を示す

このスタブファイルをCDC解析に含めることで、QuestaCDCは**正しくクロックドメイン間の接続関係を追える**ようになります。

---

必要であれば、スタブファイルと一緒に使う `.sdc` ファイルの例（クロック制約）もご紹介できますよ。

## USER
ご提案いただいたクロック制約もご紹介いただけますか？

また、MMCMは入力クロックと出力クロックが必ずありますが、入力ロックだけクロック設定するのではなく、MMCMの出力クロックも個別にクロック設定する必要があるのですね？

クロック設定はnetlist clock コマンドでクロック名、周期、グループ名を設定すると認識してます。

## ASSISTANT
はい、非常に本質的なポイントに触れておられます。その通りで、**QuestaCDCにおいては、MMCMなどのクロック変換ブロックに対して**：

- **入力クロックだけでなく、出力クロックも明示的にクロックとして定義する必要があります。**
- さらに、**CDCの判定精度を高めるために、出力クロックごとにグループ分け（clock group）を行うのがベストプラクティス**です。

---

## 1. QuestaCDC用 `.sdc` クロック制約の例

以下は、MMCMの入力クロック `clk_in1`（100MHz）と出力クロック `clk_out1`（200MHz）を使っている場合の `.sdc` 記述例です：

```tcl
# 入力クロック定義（MMCMのin端子につながるクロック）
create_clock -name clk_in1 -period 10.0 [get_ports clk_in1]

# 出力クロック定義（MMCMから出てくるクロック）
create_generated_clock -name clk_out1 \
    -source [get_ports clk_in1] \
    [get_ports clk_out1] \
    -multiply_by 2 -divide_by 1

# クロックグループを分ける（異なるドメインとして認識させる）
set_clock_groups -asynchronous \
    -group { clk_in1 } \
    -group { clk_out1 }
```

---

## 2. 質問への回答まとめ

### Q1. **MMCMの入力クロックだけでなく、出力クロックも個別にクロック設定する必要がありますか？**

→ **はい、必要です。**
- QuestaCDCはクロック名ベースでCDCの境界を解析するため、**出力クロックを定義しないと、CDC境界の片側が「未定義」扱いになる**可能性があります。
- MMCMはクロックを変換しているため、「別ドメインのクロック」と見なすのが正しい扱いです。

---

### Q2. **クロック設定は `netlist clock` コマンドで行いますか？**

→ **はい、QuestaCDCの場合は `.sdc` ファイルで `create_clock` や `create_generated_clock` を使うのが一般的です。**
- `netlist clock` はタイミング検証系ツールで使う言い方（Synopsys Design Constraints）ですが、**QuestaCDCでも同じ `.sdc` 書式に従って `create_clock` 系で設定します**。
- そのうえで、**CDC解析の際には `set_clock_groups` を使って、どのクロックが非同期（別ドメイン）であるかを明示する必要があります。**

---

## 3. 補足：複数出力クロックがある場合

MMCMが複数の出力クロックを出している場合、それぞれについて `create_generated_clock` を使い、グループ分けもすべて記載します：

```tcl
create_generated_clock -name clk_out1 ...
create_generated_clock -name clk_out2 ...

set_clock_groups -asynchronous \
    -group { clk_in1 } \
    -group { clk_out1 } \
    -group { clk_out2 }
```

---

## まとめ

- **MMCMの出力クロックは必ず `.sdc` にて個別にクロック定義が必要です。**
- **入力クロックと出力クロックは別ドメインなので、`set_clock_groups` で非同期に分けておくのが推奨です。**
- `.sdc` では `create_clock` / `create_generated_clock` / `set_clock_groups` の3要素がCDCにおける基本です。

---

ご希望であれば、実際のIPの構成に合わせた `.sdc` テンプレートや、VivadoのXDCからCDC向けに変換する方法もお手伝いできます。お気軽にお知らせください。

## USER
使用しているQuestaCDCはLinux版で、バージョンは10.6.fです。

クロック設定、各入出力品がどのクロックに同期しているかをtclファイルをに記述し、そのファイルをqverifyコマンド実行時に読み込ませるようにしてます。

そのtclファイルには以下のようなコマンドで設定しています。

netlist clock CPU_CLK -period 25000 -group grpCPU_CLK
netlist clock clk_out1 -period 2500 -group grpCPU_CLK
netlist clock sysclk_in -period 62500 -groupSYSCLK
netlist clock SYSCLK -period 62500 -group grpSYSCLK

netlist port domain CPU_CS0_n -input -clock grpCPU_CLK
...

基本的にはnetlist clockコマンドとnetlist portコマンドの２種類のみ使っています。

クロック2信号入力され、一つはCPU_CLKをFPGA外部から入力し、MMCMを通してclk_out1へ出力されます。
もう一つはsysclk_inをFPGA外部から入力し、別のMMCMを通してSYSCLKへ出力されます。

このような指定で合ってますでしょうか？


## ASSISTANT
はい、QuestaCDC（バージョン 10.6.f）で `netlist clock` および `netlist port` コマンドを用いて `.tcl` ファイルを記述する方法は、**古いバージョンのQuestaCDCの仕様に準拠した正しいスタイルです。**

そして、現在のクロック構成と制約記述を見る限り、**基本的な構成・書き方は合っています。**  
ただし、**いくつか注意点や改善提案**がありますので、以下に整理して解説します。

---

## あなたの構成の理解と現状

### クロック構成：

- **`CPU_CLK`** ：外部入力 → MMCM → **`clk_out1`**（高速クロック）へ
- **`sysclk_in`** ：外部入力 → MMCM → **`SYSCLK`**（低速クロック）へ

### `.tcl` ファイル記述（抜粋）：

```tcl
netlist clock CPU_CLK -period 25000 -group grpCPU_CLK
netlist clock clk_out1 -period 2500 -group grpCPU_CLK
netlist clock sysclk_in -period 62500 -group grpSYSCLK
netlist clock SYSCLK -period 62500 -group grpSYSCLK

netlist port domain CPU_CS0_n -input -clock grpCPU_CLK
```

---

## 評価と確認ポイント

### 1. **MMCM出力クロックのクロック定義は明示されているか？ → YES**
- `clk_out1` や `SYSCLK` を `netlist clock` で定義しているため、**出力クロックも個別に定義できています。**
- OKです。

---

### 2. **クロックグループは意図通り？ → YES（意図に合っていれば）**

`-group grpCPU_CLK` と `-group grpSYSCLK` に分けており、これは：
- **CDC解析で「別のドメイン」として認識させるために必要**です。
- 実際にこの2つのドメイン間でCDCがあるなら、このグループ分けで正解です。

---

### 3. **信号がどのクロックに同期しているかを明示しているか？ → YES**

```tcl
netlist port domain CPU_CS0_n -input -clock grpCPU_CLK
```

のように指定しているので、**入力信号がどのクロックでサンプリングされるかを正しく伝えています。**

同様に、出力信号であれば `-output` を付けます：

```tcl
netlist port domain data_out -output -clock grpSYSCLK
```

---

## 改善提案・追加の確認事項

### 1. **MMCMに関する制約の補足（必須ではない）**

もしMMCMの入力・出力クロック間で特別な関係があることを明示したい場合は：

```tcl
# これは任意だが、clk_out1 が CPU_CLK から派生したことを示す
netlist derived_clock clk_out1 -source_clock CPU_CLK
```

→ **これはQuestaCDCが自動で解析できない派生クロックの関係性を手動で補足する場合に使います。**  
通常は `netlist clock` だけで十分ですが、ドメイン誤認識が発生する場合は使うと有効です。

---

### 2. **MMCMのインスタンスがブラックボックスになっているか確認**

- MMCM IP部分にスタブファイルを含めること（前の会話通り）
- スタブが読み込まれていないと、CDC経路の途中が "undefined instance" で止まる可能性あり

---

### 3. **CDC結果に「unclocked register」「unknown domain」などの警告がないか確認**

これは `.tcl` 記述ミスやスタブ漏れで起こることがあります。`qverify` 実行後のレポートやログをチェックしてください。

---

## まとめ

- 現在の `.tcl` の記述は、QuestaCDC 10.6.f においては **構文的にも論理的にも正しく記述されています。**
- `netlist clock` と `netlist port` の2種類でドメイン指定をしていれば、基本的なCDC解析は問題なく動作します。
- **出力クロックの個別指定とグループ分けは必須で、それもできているためOKです。**
- 追加で「クロックの派生関係」や「MMCMスタブの正確な読み込み」を確認すると、より正確な解析が可能です。

---

必要であれば `.tcl` ファイルの全文レビューや、CDCレポートの解析アドバイスも対応できますので、気軽にどうぞ。

## USER
クロック指定で、-periodオプションで周期を無単位で指定しました。ここで各クロック間の周期指定値は比が正しければ単位は気にしなくてもよいのでしょうか？例えばCPU_CLK 40MHzとsysclk_inが16MHzの場合、250と625で指定しても良いのでしょうか？

## ASSISTANT
はい、ご認識の通りで、**`-period` オプションで指定する値は「単位なしの数値」ですが、**QuestaCDCでは：

> **すべてのクロック周期が** *同じ単位系* **で整合していれば、絶対単位（nsやps）でなくても** **問題ありません。**

---

## この点のポイントを整理すると：

### 1. **QuestaCDCの`-period`値は**「単位なし」扱い（相対評価）

- QuestaCDC は**タイミング解析ツール**ではなく、**CDC経路の検出が目的の静的検証ツール**です。
- したがって、`-period` の値は**タイミング検証用途ではなく、クロックの速さの相対関係を推定する**ために使われます。
- つまり、**比率が正しければ、単位は何でもOK**です。

---

### 2. **例：40MHzと16MHzの場合**

| クロック      | 周波数 | 周期（ns） | `-period` 指定値の例 |
|---------------|--------|------------|----------------------|
| `CPU_CLK`     | 40MHz  | 25ns       | 250                  |
| `sysclk_in`   | 16MHz  | 62.5ns     | 625                  |

→ **このように指定してOKです。**  
理由：**625 ÷ 250 = 2.5** → 周波数比が 1:2.5 で一致しており、ツールは相対的にどちらが速いかを把握できます。

---

### 3. **注意すべきケース**

- すべてのクロックの `-period` を **同一スケールで記述することが大前提**です（たとえば全てnsベースやpsベースなど）。
- もし一部だけ異なるスケール（例：nsとpsを混在）にしてしまうと、**誤ったドメイン判定**や**誤検出・未検出**が起こることがあります。

---

### 4. **おすすめ運用方針**

- **明確にスケールを決めておく（例：すべてnsの10倍で指定）**
  - 例：40MHz → 25ns → 250（10x）
  - 例：16MHz → 62.5ns → 625（10x）

このように決めておくと、設計変更時や他メンバーとのやりとりでブレが減ります。

---

## まとめ

- `-period` は単位なしですが、**すべてのクロックでスケールを統一していれば、比さえ合っていれば問題なし**です。
- よって、**40MHz → 250、16MHz → 625 のような指定でもOK**です。

---

不安な場合は、`qverify` のCDCレポートで「クロック名」と「周期値の認識結果」を確認して、ツールが正しく解釈しているかをチェックすると安心です。

## USER
クロックの相対的な比だけあっていれば問題ないとのことで承知しました。

次にQuestaCDCで非同期に先立って、unisimを事前コンパイルするべきかどうかについて教えてください。

他の人の検証用のスクリプトを見ると、事前に

unisim_VCOMP.vhd、unisim_VPKG.vhd、BUFG.vhd、IBUFG.vhd、MMCME2_ADV.vhd、ODDR.vhd

などのモジュールをコンパイルしているようでした。例えばMMCMはスタブファイルを使っているので不要かと思ったのですが、どうでしょうか？

## ASSISTANT
非常に良い視点です。結論から言うと、**QuestaCDCの目的に応じて「unisimの事前コンパイルが必要かどうか」は場合によります**。以下に詳しく整理してご説明します。

---

## ◆ 基本方針：**スタブを使ってブラックボックス化するなら unisim のコンパイルは不要**

たとえば、MMCM (`MMCME2_ADV.vhd`) を含むFPGA IPブロックに対して **スタブファイルでブラックボックス化している場合**：

- QuestaCDCはそのIPの**内部構造に立ち入らず**、**ポートの存在とクロック関係だけを見てCDCを解析**します。
- よって、**MMCMやBUFGなど unisim にある詳細な実装ファイルは不要**です。

---

## ◆ では、なぜ他の人のスクリプトでは `unisim_*.vhd` をコンパイルしていたのか？

これは主に以下のような理由が考えられます：

### 理由①：**スタブではなく、MMCMなどの構造を一部でも展開している**
- Vivado IPをラッパー付きで含める構成で、MMCMのインスタンスが `MMCME2_ADV` を含んでいると、**その中身までCDC対象に含められてしまう**ケースがあります。
- その場合、MMCMの構造が `unisim` にある `MMCME2_ADV.vhd` に依存するため、**コンパイルが必要**になります。

### 理由②：**クロックバッファ（BUFG, IBUFG）などの構造を含めて解析したい**
- クロックがBUFGやODDRなどを経由しており、**その構造を含めてCDCパスを正確に追いたい**場合、`unisim` の定義が必要になります。

### 理由③：**古いスタイルの制約記述やツール設定に依存**
- 特に QuestaCDC v10 系では、ツールが内部で `unisim` 参照を自動処理できないこともあり、**明示的に `unisim` を入れて解析を安定させるため**という目的もあり得ます。

---

## ◆ では、**MMCMだけスタブで処理するなら unisim のコンパイルは不要**？

→ **はい、その通りです。**  
MMCM（`MMCME2_ADV`）をスタブで置き換えているのであれば、その中身（unisimにあるVHDL）はCDC解析の対象外となり、**コンパイルしなくても解析できます**。

---

## ◆ CDC精度を上げたい場合は unisim を使うのも一つの手

以下のような方針にするのもありです：

| 方針                                | unisim 必要性     | 備考 |
|-------------------------------------|--------------------|------|
| MMCMなどはスタブで扱い、外部だけ見る | **不要**           | 軽量・シンプル |
| BUFG、ODDRなども含めてCDC構造解析    | **必要**（`unisim`必要）| CDCの精度・詳細向上 |
| IPブロック全体のクロック伝搬を追いたい | **必要**           | 大規模設計では有効 |

---

## ◆ まとめ

- **MMCMをスタブで扱うなら `unisim` の事前コンパイルは不要**です。
- ただし、**BUFG などのクロック配線要素や IP の構造をCDC解析対象に含めたいなら、`unisim` モジュールを事前にコンパイルしておく必要があります**。
- 他の人のスクリプトは、**より詳細なCDC解析をしたり、構造展開を避けない設計方針**で作られている可能性があります。

---

もし `unisim` を含めた方がよいケースかどうか判断に迷うようでしたら、今の設計で CDC レポートに「不完全なクロック経路」「unresolved instance」などの警告が出るかを見て判断するのが良いです。

また必要であれば、`vcom` で `unisim` をどうコンパイルすべきか、コマンド例もご紹介できます。

## USER
MMCMなどをunisimを使って非同期解析する場合、仮にunisim内でviolationが起こったとしても実際に対策はできないのではないか？と考えてますがどうでしょうか？

## ASSISTANT
はい、そのご認識は**非常に的確です**。まさにQuestaCDCで **`unisim` 内のプリミティブ（MMCME2_ADV や BUFG など）を展開してCDC解析した場合に警告やviolationが出ても、それに対してユーザが直接対策するのは現実的ではない**、という状況は確かにあります。

以下に、その背景と扱い方を詳しく解説します。

---

## ◆ なぜ `unisim` 内の violation は「対策不能」になるのか？

### 1. **unisim は AMD (旧Xilinx) 提供のプリミティブ・ライブラリ**
- たとえば `MMCME2_ADV` は MMCM のハードマクロに近い抽象的な振る舞いを持つコンポーネントです。
- 中身は、**ユーザが編集できるような論理構造ではない**ため、**そこでCDC violationが出ても、ユーザが中の構造を変えることはできません。**

---

### 2. **QuestaCDCが unisim の内部構造まで展開すると、ツールの自動判定で警告が出る可能性がある**
たとえば、以下のような警告が出ることがあります：

- 「データが非同期にサンプリングされているが、同期回路が検出できない」
- 「ドメインをまたぐFFが unisim 内に存在する」

→ これらは、**ツールが「FFの配置や接続が不自然だ」と判断した結果**ですが、**実際にはMMCMの動作仕様上問題ない（またはユーザが制御できない）場合がほとんど**です。

---

### 3. **現実的に対応できるのは、MMCMの**「**前後のクロックドメイン間での信号受け渡し**」**のみ

- MMCMの**入力と出力でドメインが切り替わる**ため、**その境界に存在する信号やFF構成に対して対策を行うのが本筋**です。
- MMCMの中で発生している違反に関しては「**ブラックボックス化**」してツールに無視させるのが一般的。

---

## ◆ ではunisimをコンパイルして解析する意味はあるのか？

→ **ありますが、用途は限定されます。**

| 目的                                      | unisim必要？ | 備考 |
|-------------------------------------------|--------------|------|
| MMCMの入出力をブラックボックス化して扱う   | 不要         | スタブ使用で軽量・高速 |
| BUFG、ODDR などの構造含めCDC経路を詳細解析 | 必要         | 精密なCDC検出のため |
| unisim内部のviolationに対処               | **不可能**   | 対応不可なので通常は無視 |

---

## ◆ このように対処するのがおすすめ

1. **MMCMやBUFGなどはスタブでブラックボックス化**
   - `syn_black_box` 属性や `*_stub.vhd` を活用
   - 必要に応じて `set_black_box` で明示的に非展開指定

2. **CDCパスの起点・終点をしっかりと制約でカバー**
   - `netlist port domain` などでドメイン指定
   - `set_clock_groups` または `-group` オプションで非同期明示

3. **unisimを使って解析した場合のviolationは、レポートに `// ignore` など注釈付きで残しつつ、設計上の対応は不要と記録**

---

## ◆ まとめ

- **MMCM など unisim 内部での violation は、設計者が対策できない構造であるため、通常は無視対象です。**
- **重要なのは MMCM 入出力の境界における CDC パスを明示的に制約・確認することです。**
- そのため、**MMCMはスタブ化してCDC解析し、unisimの構造を展開しないのが一般的かつ実務的です。**

---

必要であれば、QuestaCDCで特定のモジュールを `set_black_box` で指定する具体例もご紹介できます。お気軽にどうぞ。

## USER
基本はIP内はstubで非同期解析対象から除外するとのことで承知しました。

ところで、unisimというものの位置づけがよくわかってません。simと付くのでシミュレーション目的のライブラリなのではないかと予想しているのですが、使い所を教えていただけますか？

## ASSISTANT
とても鋭い観察です。「**unisim**」という名前から「simulation（シミュレーション）」用途に特化しているのでは？という考えは正しい方向性を含んでいますが、正確には **AMD（旧Xilinx）FPGAのプリミティブ部品群を定義した公式ライブラリ**です。  
シミュレーションだけでなく、**合成や論理検証にも関わる**役割を持っています。

---

## ◆ unisimの位置づけと概要

### ■ 正式な意味：
> **unisim** = **UNIversal SIMulation** ライブラリ（の略）

- AMDが提供する、**FPGA内部の基本プリミティブを定義したVHDL/Verilogライブラリ**です。
- `BUFG`, `IBUFG`, `MMCME2_ADV`, `ODDR`, `ISERDES`, `OSERDES` などの **ハードマクロ部品（FPGA固有の低レベル要素）**が含まれます。
- **シミュレーションツールで正しく動作・解析するために必要なモデル**を含みますが、それに加えて：
  - 合成ツール（Vivado）
  - CDC解析ツール（QuestaCDCなど）
  - タイミング解析ツール（Static Timing Analyzer）
  
  にも関与する重要なライブラリです。

---

## ◆ 使いどころ・用途

| 用途                      | 説明 |
|---------------------------|------|
| **論理シミュレーション**       | シミュレーション時に `MMCME2_ADV` や `BUFG` の**機能的な振る舞い**を再現するため |
| **CDC解析**                | クロックの生成・配線構造が `BUFG`, `ODDR` を通る場合、その**正しいクロック経路をモデル化**するため |
| **タイミング収束解析**        | `ODDR` などのプリミティブが**非同期データに関与する場合**の警告検出に必要 |
| **スタブ生成元として**        | Vivadoが `*_stub.vhdl` を自動生成する際にも `unisim` にあるプリミティブ定義を参照している |

---

## ◆ なぜ「simulation」と名前がついているのにシミュレーション以外にも使うのか？

これは歴史的な命名です。初期は「**論理シミュレーションのためのライブラリ**」として始まりましたが、Vivadoなどのツールが高度化するにつれ：

- 合成やCDC解析時に「プリミティブの入出力構造・振る舞い」まで含めてモデル化が必要
- よって、**unisimを単なるシミュレーション用ライブラリとしてだけでなく、ツール内部の構造解析にも使う**ようになった

という経緯があります。

---

## ◆ Vivadoにおける unisim の格納場所（参考）

Vivadoをインストールすると、下記のような場所に格納されています：

```bash
<Vivadoインストールパス>/data/vhdl/src/unisims/
```

ここに、以下のようなファイルがあります：

- `unisim_VCOMP.vhd`：コンポーネント宣言集（package）
- `unisim_VPKG.vhd`：定数や型などの定義（package）
- `BUFG.vhd`, `MMCME2_ADV.vhd`：個々のプリミティブ定義

---

## ◆ このため、実務でのunisimの使い所は以下のようにまとめられます：

| 目的                        | 必要性                     | 使用する unisim |
|-----------------------------|------------------------------|------------------|
| 論理シミュレーション        | 必須                         | `MMCME2_ADV.vhd` など |
| QuestaCDCで構造展開したい場合 | 必須（展開対象に含めるなら） | 同上               |
| ブラックボックス化で処理    | 不要（スタブで代替）         | 使用しない         |
| Vivadoでスタブ生成         | 背景で使用（自動的）         | Vivado内部         |

---

## ◆ まとめ

- **unisimは、AMD FPGAの内部プリミティブを定義するライブラリで、名前に「simulation」と付きつつも、合成や解析にも使われる重要なコンポーネント集です。**
- **使用するかどうかは、設計でその中身まで展開して扱いたいかどうかで決まります。**
- **スタブでIPをブラックボックス化する場合は、基本的にunisimの個別ファイルを読み込む必要はありません。**

---

ご希望があれば、Vivadoのunisimライブラリの取り込み方法や、vcomを使ったコンパイル例もご紹介できます。

## USER
ModelsimなどVivado以外のシミュレータでシミュレーション実行時に明示的に使うイメージが合ったのですが、合成にも使われているのですね？例えばVivadoでの合成・配置配線する際にもバックグラウンドで使われているのでしょうか？

## ASSISTANT
はい、まさにそのとおりです！  
**`unisim` ライブラリは、Vivado 以外のシミュレータ（ModelSim や QuestaSim など）で** *明示的に読み込む* **という使い方が一般的に知られていますが、Vivado の合成や配置配線（Synthesis / Implementation）でも**、**バックグラウンドで自動的に使われています。**

---

## ◆ Vivadoで unisim が使われるケース

Vivado においては、ユーザが明示的に `unisim` を「使う」と宣言しなくても、**内部で使用される設計要素（プリミティブ）に応じて、Vivado自身が自動的に unisim の定義を参照しています。**

### たとえば：

- `MMCME2_ADV`（MMCM）
- `BUFG`, `IBUFG`（グローバルバッファ）
- `ODDR`, `IDDR`（DDR転送）
- `OSERDESE3`, `ISERDESE3`（高速シリアル化）

これらはすべて `unisim` にあるプリミティブであり、Vivadoで使用すると：

- **合成中（Synthesis）に「このプリミティブはこのロジックで処理する」という情報を参照**
- **配置配線中（Place & Route）に「このリソースはFPGAのこの部分にマップされる」という制約を持つ**

→ つまり、**Vivadoは unisim の定義情報をもとに、FPGA内の物理リソースへ正確にマッピングしている**のです。

---

## ◆ なぜVivadoで unisim を意識しないで済むのか？

- Vivadoには `unisim` ライブラリが**内部的にバインド済み（事前登録済み）**です。
- IP生成やRTL記述でプリミティブを使うと、自動的に unisim にある定義が解決されます。
- ユーザが明示的に `vcom` などでコンパイルする必要が**ありません**。

一方、**Vivado外のツール（ModelSim/Questaなど）では明示的に unisim をコンパイルしないとプリミティブが未定義扱いになるため**、手動で読み込む必要があります。

---

## ◆ 合成だけでなく、スタブ生成・クロック処理にも使われている

Vivadoが自動生成する以下のようなファイル：

- `*_stub.vhd`
- `*_clk_wiz.vhd`
- `*_wrapper.vhd`

これらは unisim のプリミティブ定義に基づいて構造化されており、MMCM や BUFG を含むIPの挙動やポート定義が正確に反映されるようになっています。

---

## ◆ まとめ

| 項目 | 説明 |
|------|------|
| **Vivadoでunisimは合成・配置配線に使われる？** | → **はい、内部的に使用されます。ユーザが意識しなくてもOKです。** |
| **ModelsimやQuestaで使う場合は？** | → **明示的に `vcom` などで `unisim` をコンパイル・読み込みする必要があります。** |
| **Vivadoがスタブやラッパーを生成する際も？** | → **はい、unisimの定義に基づいて構造を生成しています。** |

---

ご希望があれば、Vivadoで使用される unisim の具体的なファイルパスや、ModelSim/Questa での `unisim` コンパイルコマンドの例もご紹介できます。

## USER
などほどVivadoで合成・配置配線・シミュレーションには意識しないでも使われているのですね。

再度unisimの名前に戻ります。
simという文字が入っているが、シミュレーションだけでなく合成の際にも参照される、とのことでした。
一方名前の中にあるuniは何かを指す言葉でしょうか？

## ASSISTANT
良いところに目をつけられましたね。「**unisim**」という名前のうち、**`sim` が simulation を指すのは明らか**ですが、前半の **`uni`** が何を意味するのかは一見わかりづらいですよね。

この `uni` は、実は次のような意味を持っています：

---

## ◆ `unisim` の語源：**"UNIversal SIMulation"**

- `uni` は **"universal"（ユニバーサル＝汎用的な、共通の）** の略
- `sim` は **"simulation"（シミュレーション）**

つまり `unisim` は、
> **「さまざまなFPGAデバイスで共通に使えるシミュレーション用プリミティブライブラリ」**

という位置づけから名付けられたものです。

---

## ◆ なぜ "universal" が重要なのか？

AMD（旧Xilinx）は多くのFPGAファミリを持っています（例：Spartan、Artix、Kintex、Virtex、Zynqなど）。それぞれで使えるプリミティブ（例：BUFG、MMCM など）の仕様はほとんど共通ですが、少しずつ異なることもあります。

そこで、Vivadoやシミュレータ側では：

- **「unisim ライブラリ」＝さまざまなFPGAデバイスに共通するプリミティブの定義**
- 特定のファミリ向けの差異が必要な場合は、`unisim` 内部で `ifdef` やパラメータにより切り替え

という方式を取って、**複数のファミリ間で共通に使えるシミュレーションライブラリ**になっているのです。

---

## ◆ 補足：Vivadoにはunisimの他にもsimprimというライブラリがある

- `unisim`：**機能シミュレーション／合成／構造解析向け**
- `simprim`：**タイミング付きシミュレーション（SDF）用**

→ `simprim` は実際のFPGAのタイミング情報（遅延など）を取り込んで、**ゲートレベルタイミングシミュレーションを行う際に使用**されます。

---

## ◆ まとめ

| 部分     | 意味                       |
|----------|----------------------------|
| `uni`    | **universal**（汎用的な、共通の） |
| `sim`    | **simulation**（シミュレーション） |
| `unisim` | 「多くのFPGAファミリで共通に使えるプリミティブのためのシミュレーション・定義ライブラリ」 |

---

つまり、**名前に「sim」が含まれていても「simulation専用」ではなく、Vivadoがバックグラウンドで幅広く使っている「共通ライブラリ」**という意味が含まれているのですね。

ご興味があれば、unisim の中で実際にどう universal に設計されているか（例：`generate` 文、ファミリ分岐など）を解説することもできます！

## USER
名前については漠然とですが汎用ライブラリとして理解できました。

Vivadoのインストールフォルダにあるunisimsフォルダには5つのファイルが置いてあります。

retarget_VCOM.vhd
unisim_regarget_VCOM.vhd
unisim_retarget_VCOMP.vhdp
unisim_VCOMP.vhd
unisim_VPKG.vhd

似たような名前やretargetがついたりつかなかったり、*.vhdpというファイルもあります。

これらはそれぞれどのような役割がありますか？

## ASSISTANT
とても良い質問です。Vivadoの `unisims` フォルダ内にあるこれらのファイル群は、**unisimライブラリをVivadoやシミュレータで使う際の「インターフェース定義」や「プリミティブの登録」を行うためのファイル**です。

似たような名前が多くてややこしいですが、それぞれには明確な役割がありますので、以下に一つずつ分かりやすく解説します。

---

## ◆ ファイル一覧と役割

### 1. `unisim_VCOMP.vhd`

**役割：**
- `unisim` に含まれるすべての**プリミティブコンポーネント（BUFG、MMCME2_ADVなど）の`component`宣言集**。
- VHDLでプリミティブを使うときに、**このファイルをライブラリにコンパイルしておくと、`component`が参照できるようになります。**

**例：**
```vhdl
component BUFG
  port (
    ...
  );
end component;
```

**使いどころ：**
- QuestaSim / ModelSim などで unisim ライブラリを作成する場合に最初に `vcom` するファイルの1つ。

---

### 2. `unisim_VPKG.vhd`

**役割：**
- unisim 用の**VHDLパッケージファイル（package）**で、型定義や定数などを含む。
- `unisim_VCOMP.vhd` の `component` 宣言を含むパッケージとして使用されることが多い。

**使いどころ：**
- VHDLコード側で `use unisim.vcomponents.all;` のように `unisim` のパッケージを参照する際に使う。

---

### 3. `retarget_VCOM.vhd`

**役割：**
- 特定のシミュレータやバージョンに応じて**プリミティブの参照先を“リターゲット（再割り当て）”するための宣言**。
- たとえば `IBUF` → `IBUF_inst` など、**コンポーネント名のエイリアスや再マッピングの設定**を行う。

**使いどころ：**
- 基本的にツール（VivadoやVCSなど）内部用。
- ユーザが直接編集したり参照する必要はない。

---

### 4. `unisim_regarget_VCOM.vhd`

**役割：**
- `retarget_VCOM.vhd` に似ていますが、**Vivado向けの合成・論理検証用として“再マッピング”（regarget）する設定を定義**。
- 特定のプリミティブがデバイスやバージョンごとに微妙に異なるときに使用。

**使いどころ：**
- これも主にVivado内部処理用。
- ユーザがこのファイルを直接コンパイルしたり、明示的に使用することは通常ありません。

---

### 5. `unisim_retarget_VCOMP.vhdp`

**役割：**
- 拡張子 `.vhdp` は、Vivado内部で使用される **テンプレート形式のVHDLファイル**（preprocessed VHDL）です。
- 内容としては、Vivadoが特定のプリミティブやデバイスファミリに応じて**retarget設定を動的に生成するための元ファイル**です。
- `.vhdp` → `.vhd` に変換されて使われるケースがあります。

**使いどころ：**
- Vivado内部で `generate` 処理や `preprocess` を使うときに使用。
- **ユーザは直接触らない・コンパイルしない**。

---

## ◆ 図でイメージするとこんな関係：

```
         +-------------------------+
         |  unisim_VCOMP.vhd      | ← component 宣言
         +-------------------------+
                   |
                   v
         +-------------------------+
         |  unisim_VPKG.vhd       | ← package 経由で使う
         +-------------------------+

[ Vivado内部 ]
         |
         +--> retarget_VCOM.vhd
         +--> unisim_regarget_VCOM.vhd
         +--> unisim_retarget_VCOMP.vhdp
```

---

## ◆ 通常ユーザが使うのは？

| ファイル               | コンパイル対象 | 理由                         |
|------------------------|----------------|------------------------------|
| `unisim_VCOMP.vhd`     | **はい**         | component宣言が必要なため      |
| `unisim_VPKG.vhd`      | **はい**         | `use`文で参照するため           |
| `retarget_VCOM.vhd`    | 通常は不要       | Vivado内部用                  |
| `unisim_regarget_VCOM.vhd` | 通常は不要   | Vivado内部用                  |
| `unisim_retarget_VCOMP.vhdp` | 不要（編集禁止） | テンプレートで直接使わない     |

---

## ◆ まとめ

- `unisim_VCOMP.vhd` と `unisim_VPKG.vhd` の2つが、ユーザ視点で最も重要で、他のファイルはVivadoやツール内部での処理用。
- `retarget` や `regarget` は、**特定ツール環境向けにプリミティブの解決先を切り替えるための内部設定ファイル**と考えればOKです。
- `.vhdp` はVivadoが使うテンプレートファイルで、ユーザは直接操作しません。

---

さらに詳しく特定ファイルの中身を見ながら知りたい場合は、その中のコードや宣言を例にしてご説明することも可能です！