#NotebookLM #VUnit #VHDL #Python 

VUnitにおいて、Pythonで記述するのはどのような位置づけの部分ですか？
また、VUnitにおいて、試験対象のVHDLコード以外にPythonと連携してVHDLで記述するのはどのような位置づけの部分ですか？

VUnitにおけるPythonとVHDLの役割について、以下に説明します。

### VUnitにおけるPythonの役割

VUnitでは、**Pythonがテストフレームワークの主要な制御層**として機能します。Pythonで記述される主な部分は以下の通りです。

*   **プロジェクトの定義と設定 (run.py)**:
    *   ユーザーは`run.py`というPythonスクリプトを作成し、VUnitを起動します。
    *   このスクリプトは、HDLソースファイルのライブラリへのマッピング、外部（プリコンパイル済み）ライブラリの追加、コンパイルオプションやシミュレーションオプションの設定など、プロジェクト全体の設定を定義する単一のエントリポイントとして機能します。
    *   Pythonの全機能が利用可能であり、ファイル選択のための動的なルールを作成したり、他のPythonパッケージをインポートしたりできます。
*   **テストの自動検出と実行**:
    *   Pythonテストランナーは、HDLソースファイルを自動的にスキャンしてテストケースを検出し、コンパイル順序を決定し、増分再コンパイルをサポートします。
    *   コマンドラインインターフェースを介して、テストのリスト表示、特定のテストの実行、ワイルドカードパターンによるテストのフィルタリングなどが可能です。
    *   複数のテストケースを並列で実行し、マルチコアマシンを活用できます。
    *   テストケースの独立性を保証し、致命的な実行時エラーが発生してもテストを続行できます。
*   **テストの設定と管理**:
    *   テストケースごとに異なるジェネリック値やパラメータ設定、シミュレーションオプションを設定できます。
    *   シミュレーションの**前後に実行されるPythonコールバック関数 (`pre_config`、`post_check`)** を定義できます。これにより、入力データの生成や出力データの自動チェックなどが可能です。
    *   テストの属性設定や、要件トレーサビリティのためのJSONレポートのエクスポート機能を提供します。
    *   JUnit形式のテストレポートファイルを出力し、JenkinsなどのCIツールとの連携を容易にします。
*   **ランダムシードの管理**:
    *   Pythonテストランナーは、各シミュレーションに対して64ビットのベースシードを自動的に生成し、これをHDLテストベンチ内の乱数ジェネレータの初期化に使用します。これにより、テストカバレッジが向上し、テストの再現も可能です。
*   **シミュレータとの連携**:
    *   Pythonは、利用可能なシミュレータを自動的に検出し、選択できます。また、シミュレータ固有のコンパイルおよびシミュレーションオプションを設定するためのインターフェースを提供します。
*   **HDLユーティリティライブラリの統合**:
    *   VUnitのPython APIを通じて、VHDLおよびSystemVerilogの組み込みライブラリ（`check`、`logging`、`communication`など）や、検証コンポーネントライブラリ、OSVVM、JSON-for-VHDLといったサードパーティのモジュールを追加できます。

### VUnitにおけるPythonと連携するVHDLコードの役割

VUnitにおいて、試験対象のVHDLコード（DUT）以外でPythonと連携して記述されるVHDLコードは、主に**テストベンチとVUnitが提供するHDLライブラリ**です。これらの役割は以下の通りです。

*   **VHDLテストベンチ**:
    *   **`runner_cfg`ジェネリック**: テストベンチは**`runner_cfg`という`string`型のジェネリック（SystemVerilogではパラメータ）**を持ち、これによりPythonテストランナーからのプライベート情報を受け取り、制御されます。
    *   **メイン制御プロセス**: すべてのVUnitテストベンチは、`test_runner`というラベル（名前は任意）のメイン制御プロセスを持ちます。
        *   **`test_runner_setup`**: プロセスの開始時に呼び出され、VUnitのセットアップを行います。
        *   **`run("Test Case Name")`**: テストケースを定義し、Pythonテストランナーによって特定のテストケースが有効化された場合に`true`を返します。テストケース名は文字列リテラルである必要があります。
        *   **`test_suite`**: `while`ループの条件として使用され、実行すべきテストケースが残っている間、ループを継続させます。
        *   **`test_runner_cleanup`**: プロセスの終了時に呼び出され、ハウスキーピングを行いシミュレーションを停止させます。この呼び出しより前にシミュレーションが停止すると、テストは失敗と見なされます。
    *   **パスのアクセス**: `runner_cfg`ジェネリックを介して、テストベンチのディレクトリパス (`tb_path`) や現在のテストの出力ディレクトリパス (`output_path`) にアクセスできます。これは、入力データの読み込みや追加の出力ファイルの作成に利用されます。
    *   **ランダムシードの利用**: `runner_cfg`から受け取ったシードを、`get_seed`関数（または`get_string_seed`, `get_integer_seed`など）を使ってVHDL内部の乱数ジェネレータの初期化に利用します。
    *   **テストウォッチドッグ**: `test_runner_watchdog`を呼び出すことで、テストケースが無限に停止するのを防ぐタイムアウトを設定できます。
    *   **属性による振る舞いの制御**: テストベンチ内で `-- vunit: run_all_in_same_sim` や `-- vunit: fail_on_warning` などのコメントを記述することで、Pythonランナーの振る舞いを制御できます。
    *   **分散テストベンチ**: 複数のプロセスが実行中のテストケースに依存する場合、`running_test_case`関数を使用して、現在実行中のテストケースの名前を取得し、それに合わせて動作を調整できます。
*   **VUnit HDLライブラリ (Builtins およびオプションライブラリ)**:
    *   **Runライブラリ**: 上記の`test_runner_setup`、`test_runner_cleanup`、`run`、`test_suite`、`get_seed`などの主要なテスト実行制御機能を提供します。
    *   **Checkライブラリ**: `check`、`check_equal`、`check_true`、`check_false`などのVHDLアサーションを拡張するチェックプロシージャや関数を提供します。チェックが失敗した場合、VUnitのロギングパッケージを使用してエラーメッセージを発行します。
    *   **Loggingライブラリ**: 階層的なロガー、さまざまなログレベル（`info`、`error`、`warning`、`debug`など）、設定可能な出力フォーマット、自動的なファイルと行番号のタグ付け、テスト中のロガーのモック機能などを提供し、デバッグとレポーティングを強化します。
    *   **Communicationライブラリ (`com`)**: アクターモデルに基づいた高レベルな通信メカニズムを提供し、複数のVHDLプロセス間で非同期にメッセージをやり取りできるようにします。これは特に検証コンポーネント間で利用されます。
    *   **Data Typesライブラリ**: キュー（`queue_t`）や動的配列（`integer_array_t`）など、HDLテストベンチで便利なデータ型を提供します。
    *   **Verification Components (VCs)**:
        *   DUTとバス信号インターフェースを介して接続されるエンティティです（例: AXI-Lite、AXI Stream）。
        *   テストシーケンスからメッセージを受け取り、実際のバス信号トランザクションを実行することで、テストベンチの抽象度を高めます。
        *   **Verification Component Interfaces (VCIs)** は、汎用的なプロシージャインターフェースを提供し、異なるVC間でのコード再利用を可能にします（例: Bus Master VCI、Stream VCI、Synchronization VCI）。
        *   **メモリモデル**と連携し、外部メモリ空間へのアクセスチェックや、期待データの検証を行います。
    *   **Identityパッケージ**: テストベンチ内の名前付きオブジェクトの階層的な組織化を可能にし、ロガーやアクターなどの内部で利用されます。
