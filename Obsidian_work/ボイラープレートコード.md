#ChatGPT #WPF 

```
質問：
MVVMを使用することで、ボイラープレートコードを削減可能との記述を見かけます。WPF、MVVMでボイラープレートコードとはどのようなものですか？
```

### 1. そもそも “ボイラープレートコード” とは

- **意味**: アプリを作るたびにほぼコピー＆ペーストで書くような“儀式的”コード。ロジックというより“型”を満たすために必要な記述。
    
- **問題点**:
    
    - 読みにくさ・行数の増加
        
    - 修正忘れやタイポによるバグ
        
    - 本質的なロジックが埋もれてレビューしづらい
        

---

### 2. WPF／MVVM 開発で代表的なボイラープレート

|領域|典型的なボイラープレート|具体例|なぜ増えるか|
|---|---|---|---|
|**プロパティ変更通知**|`INotifyPropertyChanged` の実装・`PropertyChanged` イベント・`SetProperty` ラッパーメソッド|`csharp\npublic class PersonVM : INotifyPropertyChanged\n{\n private string _name;\n public string Name\n {\n get => _name;\n set\n {\n if(_name != value)\n {\n _name = value;\n OnPropertyChanged(nameof(Name));\n }\n }\n }\n // …同じパターンが大量に続く\n}\n`|ViewModel のすべてのプロパティで同じパターンが必要|
|**コマンド定義**|`ICommand` ラッパークラス (`RelayCommand`, `DelegateCommand` など) の生成とプロパティ実装|`csharp\npublic ICommand SaveCommand { get; }\n\npublic MainVM()\n{\n SaveCommand = new RelayCommand(Save, CanSave);\n}\n`|各操作ごとに1コマンド＋CanExecute 判定を書く|
|**View ↔ ViewModel の紐付け**|Code-behind での DataContext 設定|`csharp\npublic partial class MainWindow : Window\n{\n public MainWindow()\n {\n InitializeComponent();\n DataContext = new MainVM();\n }\n}\n`|ほぼ全ウィンドウ／UserControlで同じ|
|**DependencyProperty 自作**|CLR ラッパと `Register()` 呼び出し|依存プロパティを持つカスタムコントロールを作るたびに必須||
|**通知付きコレクション**|`ObservableCollection<T>` ラップ＋イベント転送|コレクション内容が View に反映されるよう同じ書き方を繰り返す||

---

### 3. MVVM Toolkit 等での削減例

|ツール／機能|削減できるコード|例|
|---|---|---|
|**CommunityToolkit.Mvvm** の `[ObservableProperty]`|手書きのバックフィールド＋`OnPropertyChanged` 呼び出し|`csharp\npublic partial class PersonVM : ObservableObject\n{\n [ObservableProperty]\n private string name;\n}\n// → ビルド時ソースジェネレータが Name プロパティと通知コードを自動生成\n`|
|`[RelayCommand]` 属性|コマンドクラス生成＆プロパティ定義|`csharp\n[RelayCommand]\nprivate void Save() { /* 処理 */ }\n// SaveCommand プロパティが自動生成\n`|
|**Caliburn.Micro / Prism** の Convention|ViewModel を置くだけで自動 DataContext|`MainViewModel ↔ MainView.xaml` の名前一致で DataContext が自動バインド|
|**Source Generator**（C#9+）|依存プロパティ・`INotifyPropertyChanged` 実装|生成コードはビルド成果物なので手書き不要|
|**Fody.PropertyChanged**|IL ウィービングで通知注入|フィールドを書くだけでプロパティ & 通知が挿入される|

---

### 4. まとめ ― “削減” がもたらすメリット

1. **実装コスト減**
    
    - コマンド・プロパティ追加が “1 行” で済む → 実装スピード向上
        
2. **バグ混入リスク低減**
    
    - タイポや `OnPropertyChanged` 書き忘れがない
        
3. **可読性向上**
    
    - ViewModel にビジネスロジックだけが残り意図が明確
        
4. **保守性向上**
    
    - 仕様変更時に修正箇所が最小限
        

> **要点**  
> MVVM 自体というより _MVVM 向けツールキットや規約_ を活用することで、  
> 「通知」「コマンド」「バインディング設定」など **機械的に書くだけの繰り返しコード** が消え、  
> ViewModel にはドメインロジックのみを集中させられる――これが“ボイラープレート削減”の正体です。