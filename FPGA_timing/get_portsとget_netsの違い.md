## USER
Vivadoのtclで使えるコマンドでget_portsとget_netsがあります。

入力信号をget_portsで指定した場合とget_netsで指定した場合、2つのコマンドの結果に違いはありますでしょうか？

## ASSISTANT
はい、`get_ports` と `get_nets` には明確な違いがあります。以下にその違いを説明します。

---

### 1. `get_ports` の意味
- **対象**: トップモジュールの **入出力ポート**
- **取得できるもの**: デザインの外部との**インターフェース**になる信号
- **例**: `input clk`, `output rst` のようなポート

#### 使いどころ:
```tcl
get_ports clk
```
→ トップレベルの `clk` ポートを取得します（FPGAピンにマッピングされる信号）。

---

### 2. `get_nets` の意味
- **対象**: デザイン内部の**配線（ネット）**
- **取得できるもの**: 各信号間の**論理的な接続線**  
- **ポートの背後のネット**も含まれる

#### 使いどころ:
```tcl
get_nets clk
```
→ `clk` という名前のネット（内部配線）を取得します。

---

### 違いの例
たとえば、以下のようなVHDL/Verilogコードがあったとします:

```verilog
module top (
    input clk
);
```

このとき、

| コマンド             | 結果                     |
|----------------------|--------------------------|
| `get_ports clk`      | clkという**ポート**       |
| `get_nets clk`       | clkという**ネット（配線）**（あれば） |

---

### 注意点
- **ポートとネットは名前が一致しても、別のオブジェクト**として扱われます。
- Vivadoの制約やスクリプトで `get_ports` しか使えない場所・逆に `get_nets` が必要な場面があります。
- `get_ports` で取得したポートに `get_nets` を使っても、必ずしもネットが取得できるわけではありません（特に途中でバッファなどが入っている場合）。

---

### 実用上の使い分け
| 目的                      | 使うコマンド     |
|---------------------------|------------------|
| ピンに関連する制約        | `get_ports`      |
| タイミングパスの制約指定 | `get_nets` または `get_pins` |

---

補足が必要でしたら、具体例つきでさらに説明します！

## USER
この質問した背景にreport_timingコマンドでget_portsで入力ポートを指定した場合と、get_netsで入力ポートの信号名を指定した場合に違いがあるのかどうか知りたいという背景があります。

## ASSISTANT
なるほど、背景をありがとうございます。その文脈（`report_timing` で `get_ports` と `get_nets` を指定した場合）での違いについて詳しく解説します。

---

## ■ `report_timing` における `get_ports` vs `get_nets`

### 基本的な考え方

- `get_ports` → **外部インターフェース（I/Oポート）**を起点・終点にするタイミングパスを対象にする
- `get_nets` → **論理的な配線（ネット）**を通るタイミングパスを対象にする

---

### ▼ 例1: 入力ポート `clk` を使った場合

#### 1. `report_timing -from [get_ports clk]`
- **意味**: 外部のピン（FPGAのpad）から `clk` ポートに入ってくるタイミングパスの**始点**
- **対象**: IOBUFやBUFGなどの**物理ピンに関係する経路も含む**

#### 2. `report_timing -from [get_nets clk]`
- **意味**: 論理ネット `clk` から始まるパス
- **対象**: `clk` が内部で接続されている**ネット配線以降**のタイミング（例: BUFG後やFFクロック入力）

→ この場合、**`get_ports` のほうがFPGAの外部I/Oパッドからのパスを含む**ため、より広い経路を報告します。

---

### ▼ 例2: 入力信号 `din` の場合

#### `report_timing -from [get_ports din] -to [get_pins -hier -filter {REF_PIN_NAME == D}]`
- **意味**: ポート `din` から内部FFのD端子までの遅延（フルパス）

#### `report_timing -from [get_nets din] -to [get_pins -hier -filter {REF_PIN_NAME == D}]`
- **意味**: `din` の内部ネット部分からの遅延。**IO遅延や入力バッファの影響が除かれる可能性あり**

---

## ■ 実際の違い（まとめ）

| 観点                     | `get_ports`                             | `get_nets`                               |
|--------------------------|------------------------------------------|-------------------------------------------|
| 対象                     | 外部I/Oポート                           | 内部のネット配線                          |
| `report_timing`での経路 | 外部ピン → IBUFなどを含む               | ネット接続部から先の論理経路              |
| パッド遅延               | 含まれる（IOSTANDARDやPACKAGE_DELAY） | 含まれない                                |
| BUFGの前                 | 含まれる                                 | BUFG以降のみになることが多い              |

---

## ■ どちらを使うべきか？

- **FPGA外部ピンからのタイミング全体を評価したい場合** → `get_ports`
- **論理設計の遅延やクロックツリー以降を確認したい場合** → `get_nets`

---

必要に応じて、`report_timing -from [get_ports XXX] -to ...` と `-from [get_nets XXX] -to ...` の両方を比較して見るのも有効です。  
特にクロック系やIOパスなど、**IO遅延やバッファの影響**を見るには `get_ports` が有用です。

---

ご希望であれば、具体的な `report_timing` のコマンド比較例も提示できますのでお知らせください。

## USER
説明いただいた内容からすると、入力ポートからのタイミングを計算する場合には、get_portsを使用する方が良いようですね。

## ASSISTANT
はい、その通りです！

**入力ポートからのタイミングパスを正確に評価したい場合には、`get_ports` を使うのが適切です。** 理由を簡潔にまとめると以下の通りです：

---

### ◆ `get_ports` が適している理由（入力ポートの場合）

| 理由 | 説明 |
|------|------|
| **物理パッド〜IBUFまでの遅延が含まれる** | 実際のFPGAピンに入ってくる信号のタイミング（IOSTANDARDや遅延モデル）まで含めたパスになるため、実動作に近いタイミングでの評価が可能です。 |
| **静的タイミング解析での「正規の始点」** | Vivadoの内部でも「入力パッド」→「内部ロジック」が正式な入力パスと定義されているため、制約やタイミングレポートの整合性が保たれます。 |
| **セットアップ／ホールド解析に対応** | クロックに対するセットアップ・ホールドのチェックを行うには、ポートが正しく始点になっている必要があります。 |

---

一方、`get_nets` を使ってしまうと、以下のような **物理的な遅延要素が無視される** 可能性があります：

- IBUF や I/O の配線
- パッケージ遅延（PACKAGE_PIN や IOSTANDARD による差異）
- 入力遷移時間（input delay）の影響

---

### ◆ まとめ：どちらを使うべき？

| 観点 | 推奨コマンド |
|------|--------------|
| **IO遅延含めたリアルなタイミング評価** | `get_ports` |
| **内部ロジックに限定した遅延評価**     | `get_nets` |

---

タイミング収束や制約検証の観点からも、**まずは `get_ports` でレポートするのが基本であり推奨されます。**

必要であれば、補足として `get_nets` で詳細な内部経路だけを抽出・比較するという使い方が有効です。

他にクロック経路や出力側のケースなどでも気になる点があれば、そこも詳しくお答えします！

## USER
提示いただいたreport_timingの例で、以下のコマンドがありました。

report_timing -from [get_ports din] -to [get_pins -hier {REF_PIN_NAME == D}]

このコマンドについて解説いただきたいのですが、-hier オプションと {REF_PIN_NAME == D}の部分が特にわかっていないので、その部分を詳しく教えていただきたいです。

## ASSISTANT
ご質問ありがとうございます。  
以下、`report_timing -from [get_ports din] -to [get_pins -hier {REF_PIN_NAME == D}]` のコマンドに含まれる要素のうち、特にご質問の **`-hier` オプション** と **`{REF_PIN_NAME == D}` のフィルター** について詳しく解説します。

---

## ■ コマンド全体の目的

```tcl
report_timing -from [get_ports din] -to [get_pins -hier {REF_PIN_NAME == D}]
```

- **入力ポート `din` から内部の全フリップフロップのD端子まで**の遅延をレポートする、という意味です。
- → これにより、**入力からFFへのセットアップタイミング**を確認できます。

---

## ■ `-hier` オプションの意味（`get_pins` に対して）

### ● 通常の `get_pins` の動作
- デフォルトでは **現在の階層（トップレベル）** だけからピンを取得します。
- サブモジュール（下位インスタンス）の中にあるピンは見つけられません。

### ● `-hier` をつけると？
- デザイン全体を**階層をたどって再帰的に検索**します。
- → 下位モジュールの内部ピン（FFのD端子など）も対象にできます。

#### 例：
```tcl
get_pins -hier
```
→ `top/u1/u2/ff_inst/D` のような**階層付きのピン名**も取得されるようになります。

---

## ■ `{REF_PIN_NAME == D}` の意味（フィルター式）

これは `get_pins` における **フィルタ条件**です。Vivadoの `-filter` や `-regexp` などと同様の検索式が使えます。

### ● `REF_PIN_NAME` とは
- 各ピンに対して「どのセルのどのピンなのか」を表す**参照ピン名（Reference Pin Name）**です。
- `D` は一般的に **フリップフロップのD端子** を表します。

#### つまり：
```tcl
{REF_PIN_NAME == D}
```
→ Dという名前のピン（つまり **FFのデータ入力ピン**）だけを取得します。

---

## ■ 結果として得られるのは？

この組み合わせにより、以下のようなピンが対象になります：

```
top/u1/u2/reg0/D
top/u1/u3/reg1/D
...
```

つまり、**入力ポート `din` から、すべてのFFのDピンまでのセットアップパス**が抽出されます。

---

## ■ 応用例

FFのクロック端子に対して使いたい場合は、以下のように変更します：

```tcl
get_pins -hier -filter {REF_PIN_NAME == C}
```

---

## ■ まとめ

| 要素                      | 説明 |
|---------------------------|------|
| `-hier`                   | サブモジュールも含めて階層的にピンを探す |
| `{REF_PIN_NAME == D}`     | FFなどの "D" という名前のピンだけを抽出する条件式 |
| 全体の効果               | 入力ポート → 全FFのD端子までのタイミングを報告する |

---

必要に応じて、このパターンを用いて **クロックのC端子・出力のQ端子** など他のピンも対象にできます。  
また、特定のモジュール配下だけに限定したい場合は、さらに `-of_objects` や `-filter` なども組み合わせ可能です。

もし、特定のパスで実際に試してみたいケースがあれば、お手伝いできます！

## USER
FFのD端子またはCE端子を同時に指定することはできますか？

また、以前入力ポートからFFまでを指定する際、FFまでの指定を以下のようにする方法を教わりました。

get_cells -hierarchical -filter {IS_SEQUENTIAL}

これらの指定の違いはありますか？

## ASSISTANT
とても良い質問です！  
以下に、**`get_pins` によるピン指定（DやCE）**と、**`get_cells -hier -filter {IS_SEQUENTIAL}` によるFFセルの取得**の違いや、それぞれの使い分け、複数ピン指定の方法について詳しく説明します。

---

## ■ 1. `get_pins` で D端子と CE端子を同時に指定するには？

はい、**同時指定可能**です。

### ▼ 方法1：OR条件で複数ピンを指定
```tcl
get_pins -hier -filter {REF_PIN_NAME == "D" || REF_PIN_NAME == "CE"}
```

このように `||`（または）を使うことで、`D` または `CE` のピンを取得できます。

---

## ■ 2. `get_pins` vs `get_cells`（+ `IS_SEQUENTIAL`）の違い

| 観点                     | `get_pins -filter {REF_PIN_NAME == ...}` | `get_cells -filter {IS_SEQUENTIAL}`     |
|--------------------------|-------------------------------------------|-----------------------------------------|
| 対象                     | **セル内のピン（DやCEなど）**             | **順序回路セル（FF, Latchなど）本体**   |
| 結果                     | `top/u1/u2/ff_inst/D` のような **ピン名**  | `top/u1/u2/ff_inst` のような **セル名** |
| 用途                     | `-to`, `-through` などで**個別ピンを対象**にできる | FF全体を対象としたクロックドメイン解析など |
| 例                       | `report_timing -to [get_pins ...]`        | `report_timing -to [get_pins -of_objects [get_cells ...]]` |

### ▼ `IS_SEQUENTIAL` の意味
- Vivadoが内部的に「順序素子（FF、ラッチなど）」として認識しているセルを抽出します。
- DFF、LDCEなどのクロックを持つ記述にマッピングされたセルが対象になります。

---

## ■ 応用：両者を組み合わせて使う例

「FFのD端子とCE端子の両方を含むすべてのピン」を対象にする場合は：

### ▼ 方法1：直接 `get_pins` に複数ピン指定
```tcl
report_timing -from [get_ports din] -to [get_pins -hier -filter {REF_PIN_NAME == "D" || REF_PIN_NAME == "CE"}]
```

### ▼ 方法2：まずFFセルを取得 → ピンを取得
```tcl
set ff_cells [get_cells -hier -filter {IS_SEQUENTIAL}]
set ff_pins [get_pins -of_objects $ff_cells -filter {REF_PIN_NAME == "D" || REF_PIN_NAME == "CE"}]
report_timing -from [get_ports din] -to $ff_pins
```

この方法は、まず**順序素子のセルだけに限定して**から、その中の `D` や `CE` ピンを対象にするため、**意図しないセル（例えばRAMのピン）を除外できる**メリットがあります。

---

## ■ まとめ

| 条件                                 | 使い分けの目安 |
|--------------------------------------|----------------|
| ピン単位（D/CEなど）を直接指定したい | `get_pins -hier -filter {REF_PIN_NAME == ...}` |
| FFなどの順序回路セルを対象にしたい   | `get_cells -hier -filter {IS_SEQUENTIAL}` → `get_pins -of_objects` |

---

どちらも用途次第で使い分けられます。  
より厳密に「FFのDとCEだけを対象にしたい」なら、`get_cells` + `get_pins -of_objects` の組み合わせがおすすめです。

ご希望があれば、特定の状況に合わせたコマンドの例も提示できます！

## USER
細かいところなのですが、説明ででてきた下記オプションは同じなのでしょうか？

-hier
-hierarchical

## ASSISTANT
とても良いご指摘です！

Vivado Tcl において、**`-hier` と `-hierarchical` は同じ意味ではありません**。  
**見た目は似ていますが、Vivadoでは別のオプションです。**

---

## ■ `-hier`（正しいオプション）

- **正式なVivadoのオプション**
- 多くの `get_*` コマンド（例: `get_cells`, `get_pins`, `get_nets` など）で使われます
- **階層を再帰的にたどって、下位階層のオブジェクトも含めて取得する**  
- よく使われる正しい書き方です

### 例：
```tcl
get_pins -hier -filter {REF_PIN_NAME == "D"}
```

---

## ■ `-hierarchical`（Vivadoでは**無効なオプション**）

- Vivadoの `get_*` 系コマンドには存在しません
- **ISEや一部の古いツール・他社ツールなどで使われていた**ことがあるため、混同されやすい
- Vivadoで使うとエラーになります：

```tcl
ERROR: [Common 17-161] Invalid option '-hierarchical'
```

---

## ■ まとめ

| オプション        | 有効性         | 意味                        |
|-------------------|----------------|-----------------------------|
| `-hier`           | **有効**       | 階層的にすべての下位オブジェクトを検索する |
| `-hierarchical`   | **無効（エラー）** | Vivadoではサポートされていない |

---

つまり、Vivadoで使うなら **`-hier` 一択** です！

もし他のスクリプト例や資料に `-hierarchical` が出てきたら、Vivado用には `-hier` に読み替えて問題ありません。